import 'dart:io';

import 'package:test/test.dart';

class TestHelpers {
  /// Creates a temporary directory for testing
  static Directory createTempDirectory([String? prefix]) {
    final tempDir =
        Directory.systemTemp.createTempSync(prefix ?? 'rj_blocx_test_');
    addTearDown(() {
      if (tempDir.existsSync()) {
        tempDir.deleteSync(recursive: true);
      }
    });
    return tempDir;
  }

  /// Creates a temporary file with content
  static File createTempFile(String content, [String? name]) {
    final tempDir = createTempDirectory();
    final file = File('${tempDir.path}/${name ?? 'test_file.txt'}');
    file.writeAsStringSync(content);
    return file;
  }

  /// Verifies that a directory structure exists
  static void verifyDirectoryStructure(
      String basePath, List<String> expectedPaths) {
    for (final path in expectedPaths) {
      final fullPath = '$basePath/$path';
      expect(
        Directory(fullPath).existsSync() || File(fullPath).existsSync(),
        isTrue,
        reason: 'Expected path does not exist: $fullPath',
      );
    }
  }

  /// Verifies file contains expected content
  static void verifyFileContains(
      String filePath, List<String> expectedContent) {
    final file = File(filePath);
    expect(file.existsSync(), isTrue, reason: 'File does not exist: $filePath');

    final content = file.readAsStringSync();
    for (final expected in expectedContent) {
      expect(
        content.contains(expected),
        isTrue,
        reason: 'File $filePath does not contain: $expected',
      );
    }
  }

  /// Mock pubspec.yaml content
  static String mockPubspecContent(String projectName) {
    return '''
name: $projectName
description: A Flutter project generated by RJ BlocX CLI.
version: 1.0.0+1

environment:
  sdk: '>=3.0.0 <4.0.0'
  flutter: ">=3.0.0"

dependencies:
  flutter:
    sdk: flutter
  flutter_bloc: ^8.1.6
  equatable: ^2.0.5
  get_it: ^7.6.7

dev_dependencies:
  flutter_test:
    sdk: flutter
  flutter_lints: ^3.0.0

flutter:
  uses-material-design: true
''';
  }

  /// Mock Flutter project structure
  static List<String> getExpectedFlutterProjectStructure() {
    return [
      'lib',
      'lib/main.dart',
      'lib/app',
      'lib/core',
      'lib/modules',
      'pubspec.yaml',
      'README.md',
      'analysis_options.yaml',
    ];
  }

  /// Mock BlocX project structure
  static List<String> getExpectedBlocXProjectStructure() {
    return [
      'lib/app/app_router.dart',
      'lib/app/service_locator.dart',
      'lib/app/bloc_observer.dart',
      'lib/core/network',
      'lib/core/constants',
      'lib/core/utils',
      'lib/core/errors',
      'lib/modules/auth/bloc',
      'lib/modules/auth/screens',
      'lib/modules/auth/models',
      'lib/modules/auth/repository',
      'lib/modules/home/bloc',
      'lib/modules/home/screens',
      'lib/modules/home/repository',
    ];
  }

  /// Validates generated class names follow conventions
  static void validateClassNaming(String className, String expectedPattern) {
    expect(
      RegExp(expectedPattern).hasMatch(className),
      isTrue,
      reason:
          'Class name "$className" does not match pattern "$expectedPattern"',
    );
  }

  /// Validates import statements in generated files
  static void validateImports(
      String fileContent, List<String> expectedImports) {
    for (final import in expectedImports) {
      expect(
        fileContent.contains("import '$import';") ||
            fileContent.contains('import "$import";'),
        isTrue,
        reason: 'Missing import: $import',
      );
    }
  }

  /// Mock API constants for testing
  static String getMockApiConstants() {
    return '''
class ApiConstants {
  static const String baseUrl = 'https://api.example.com';
  static const String login = '/auth/login';
  static const String register = '/auth/register';
  static const String logout = '/auth/logout';
  static const String refreshToken = '/auth/refresh';
  static const String profile = '/user/profile';
  static const String dashboard = '/dashboard';
}
''';
  }

  /// Convert string to PascalCase (for testing without external dependencies)
  static String toPascalCase(String input) {
    if (input.isEmpty) return input;

    return input
        .split(RegExp(r'[_-]'))
        .map((word) => word.isNotEmpty
            ? word[0].toUpperCase() + word.substring(1).toLowerCase()
            : '')
        .join('');
  }

  /// Convert string to camelCase (for testing without external dependencies)
  static String toCamelCase(String input) {
    if (input.isEmpty) return input;

    final pascalCase = toPascalCase(input);
    return pascalCase[0].toLowerCase() + pascalCase.substring(1);
  }

  /// Convert PascalCase or camelCase to snake_case (for testing)
  static String toSnakeCase(String input) {
    if (input.isEmpty) return input;

    return input
        .replaceAllMapped(
            RegExp(r'([a-z])([A-Z])'), (match) => '${match[1]}_${match[2]}')
        .toLowerCase();
  }

  /// Validate project name (Flutter naming convention)
  static bool isValidProjectName(String name) {
    if (name.isEmpty) return false;

    // Must start with lowercase letter
    if (!RegExp(r'^[a-z]').hasMatch(name)) return false;

    // Can contain only lowercase letters, numbers, and underscores
    if (!RegExp(r'^[a-z][a-z0-9_]*').hasMatch(name)) return false;

    // Cannot end with underscore
    if (name.endsWith('_')) return false;

    // Cannot have consecutive underscores
    if (name.contains('__')) return false;

    return true;
  }

  /// Validate module/screen name
  static bool isValidModuleName(String name) {
    if (name.isEmpty) return false;

    // Allow letters, numbers, underscores, hyphens
    return RegExp(r'^[a-zA-Z][a-zA-Z0-9_-]*').hasMatch(name);
  }
}
